# Memo

## chapter_02

### 2.1

Pythonのオブジェクトは少なくとも以下の情報を持つ。

- 型
- ID
- 値
- 参照カウント

### 2.7

変数はオブジェクトを指す名前であって、その中に値が入っているわけではない

## chapter_03

### 3.2

#### 3.2.5

bin(),oct(),hex()は10進整数を基数付きの文字列に変換する

chr(),ord()はそれぞれ整数と文字の変換を行う。

## chapter_04

### 4.5

in演算子で所属関係を調べられる。

``` 'o' in 'aeiou' ``` はTrue

### 4.6

`:=`を使えば代入と条件比較を一度に行える

``` if(diff := tweet_limit -len(tweet_string)) >=0: ```

## chapter_05

### 5.1

raw文字列を使うと文字列内のエスケープシーケンスがエスケープシーケンスとして解釈されないようになる。

### 5.10

.split(),.join()はそれぞれ文字列の分解、結合を担う

### 5.12

.strip(),.lstrip(),.rstrip()はパディングを削除する。引数を指定しなければ空白を削除する。

## chapter_07

### 7.1

#### 7.1.1

タプルの要素が一つのとき、要素の後に,をつける
```one_marx=('Groucho',)```

### 7.2

#### 7.2.7

insert()はオフセットを指定した要素の追加ができる

```list.insert(2,'Gummo')```

`list[2]`に追加

#### 7.2.9

extend()は二つのリストを連結する

```marxes.extend(others)```

#### 7.2.12

delはオフセットを指定して要素を削除する

```del marxes[-1]```

#### 7.2.13

remove()は値を指定して要素を削除する

```marxes.remove('Groucho')```

#### 7.2.14

pop()でオフセットを指定したポップができる(引数無しだと末尾の要素がポップされる)

```marxes.pop()```

#### 7.2.16

index()で要素の値からオフセットを取得する（複数ある場合ははじめの要素のみ）

```marxes.index('Chico')```

#### 7.2.19

join()でリスト内の文字列を連結できる(joinは文字列の関数であることに注意)

```', '.join(marxes)```

## chapter_08

### 8.1

#### 8.1.2

dict()に名前付き引数と値を渡すことでも辞書を作れる

```acme_cutomer=dict(first='Wile',middle='E',last='Coyote')```

#### 8.1.10

**を使って辞書のマージができる.ここでは参照のコピーが行われている

```first={'a':'agony','b':'bliss'}```
```second={'b':'bagels','c':'candy'}```
```{**first,**second}```
```{'a':'agony','b':'bagels':'c':'candy'}```

#### 8.1.11

update()を使うと辞書を別の辞書にコピーできる。

```pythons.update(others)```

pythonsとothersに同一のキーがある場合はothersのキーが残る

#### 8.1.12

delを使うとキーを指定して要素を削除できる

```del pythons['Marx']```

#### 8.1.13

pop()はget()とdelを組み合わせた動作をする

```pythons.pop('Palin')```

#### 8.1.20

辞書を反復処理するとキーが返される。バリューを反復処理したい場合はvalues()を、キーとバリューの両方を使いたい場合はitems()を使う

#### 8.1.21

辞書でも内包表記が使える。

```word='letters'```
```letter_counts={letter : word.count(letter) for letter in word}```

### 8.2

#### 8.2.8

集合の演算子

- &:共通部分
- |:和集合
- -:差集合
- ^:排他的論理和
- <=(またはissubset()):部分集合になっているか

#### 8.2.10

frozenset()を使うと書き換え不可能な集合を作れる

## chapter_09

### 9.3

#### 9.3.5

関数定義の中で*を使うと、可変個の位置引数がタプルにまとめられて仮引数にセットされる。

```def print_args(*args):```
```print('Positional tuple:',args)```
```print_args(3,2,1,'wait!','uh...')```
```Positional tuple: (3,2,1,'wait!','uh...')```

関数呼び出しの中で*を使うと、タプルをカンマ区切りの位置仮引数に分解する。

#### 9.3.6

関数定義の中で**を使うと、キーワード引数を1個の辞書にまとめることができる
関数呼び出しの中で**を使うと、辞書をキーワード引数に分解できる

#### 9.3.7

*以降の引数はキーワード引数としてしか使えない
```def print_data(data,*,start=0,end=100):```

### 9.4

関数定義の先頭に組み込んだ文字列をdocstringという。docstringはhelp(関数名)で呼び出せる。

### 9.6

関数内関数はクロージャとして機能する。外側の関数に与える引数の値によって異なる関数を定義することができる

### 9.8

#### 9.8.1

値をyieldで返せばジェネレータ関数を作れる。ジェネレータは一度使用すると中身が空っぽになる。

#### 9.8.2

()で囲んだ内包表記はジェネレータ内包表記。

### 9.10

関数内でglobal 変数名 と書くと、その関数内ではグローバル変数を参照するようになる。
書かないと、関数内でのみ使用可能なローカル変数を作成することになる。
